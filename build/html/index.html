
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Welcome to T_Tensor’s documentation! &#8212; T_Tensor 1.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="welcome-to-t-tensor-s-documentation">
<h1>Welcome to T_Tensor’s documentation!<a class="headerlink" href="#welcome-to-t-tensor-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<span class="target" id="module-Tensor"></span><dl class="class">
<dt id="Tensor.Tensor">
<em class="property">class </em><code class="descclassname">Tensor.</code><code class="descname">Tensor</code><span class="sig-paren">(</span><em>slices=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>This is a class of 3rd order sparse tensors which is designed to support
the t-product.</p>
<dl class="docutils">
<dt>Tensor Class</dt>
<dd><dl class="first last docutils">
<dt>Private:</dt>
<dd><dl class="first last docutils">
<dt>_slices - (list of sparse matrices or 3rd order ndarray)</dt>
<dd>a list of sparse scipy matrices which represents the frontal slices of
the tensor, i.e. the t-th element of the list will be the matrix
A[:,:,t]. All slices will be the same type of sparse matrix. If
slices is passed in as an ndarray, then it must only have 3
dimensions.</dd>
<dt>_slice_format - (string)</dt>
<dd>a string indicating the sparse matrix format of each of the frontal
slices in the tensor. If _slices is an ndarray it will be set to
‘dense’</dd>
<dt>shape - (tuple of ints)</dt>
<dd>a tuple with the shape of the tensor. The ith element of shape
corresponds to the dimension of the ith mode.</dd>
</dl>
</dd>
<dt>Public Methods:</dt>
<dd>save
load
convert_slices
set_frontal_slice
get_front_slice
set_scalar
get_scalar
resize                SPARSE UNFINISHED
transpose              DENSE UNTESTED
squeeze
twist
t-product                    DENSE CASE UNTESTED
scale_tensor
find_max
is_equal_to_tensor
frobenius_norm               UNTESTED
norm                         UNTESTED
cos_distance m
to_dense</dd>
<dt>Overloaded Methods:</dt>
<dd>__add__
__sub__
__mul__                      UNTESTED
__neg__
__eq__                       UNTESTED
__ne
__getitem__                  DENSE UNTESTED
__setitem__                  UNWRITTEN</dd>
</dl>
</dd>
<dt>Class utilization</dt>
<dd>zeros
normalize                      UNTESTED</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>TODO: -write a reshape function</dt>
<dd>-update the convert slices to convert to dense or to sparse
-write random Tensor
-write print overloading
-add in non-zero count private element?</dd>
</dl>
<dl class="method">
<dt id="Tensor.Tensor.convert_slices">
<code class="descname">convert_slices</code><span class="sig-paren">(</span><em>format</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.convert_slices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.convert_slices" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function will convert all of the slices to a desired sparse matrix     format, this derives its functionality from the scipy.sparse._.asformat     function. To convert to a dense tensor, use todense().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt>format- (string)</dt>
<dd><p class="first last">string that specifies the possible formats, valid formats are the         supported formats of scipy sparse matrices. see scipy reference for         most up to date supported formats.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">References:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/sparse.html">https://docs.scipy.org/doc/scipy/reference/sparse.html</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.find_max">
<code class="descname">find_max</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.find_max"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.find_max" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the largest element of the tensor.</p>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.frobenius_norm">
<code class="descname">frobenius_norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.frobenius_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.frobenius_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Frobenius norm of the tensor. Computed using scipy’s norm     function for numerical stability.</p>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.get_frontal_slice">
<code class="descname">get_frontal_slice</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.get_frontal_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.get_frontal_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the t-th frontal slice. Paired with set_slice().</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>t - (int)</dt>
<dd>index of the slice to return</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>slice - (sparse scipy matrix or ndarray)</dt>
<dd>the t-th slice</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.get_scalar">
<code class="descname">get_scalar</code><span class="sig-paren">(</span><em>k</em>, <em>j</em>, <em>i</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.get_scalar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.get_scalar" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function gets the i,j,k element of the tensor. paired with the     set_scalar function.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt>i - (integer)</dt>
<dd><p class="first last">The mode 1 index to insert the scalar</p>
</dd>
<dt>j - (integer)</dt>
<dd><p class="first last">The mode 2 index to insert the scalar</p>
</dd>
<dt>k - (integer)</dt>
<dd><p class="first last">The mode 3 index to insert the scalar</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>A[i,j,k] - (scalar number)</dt>
<dd><p class="first last">returns the value at the i,j element of the kth frontal slice.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.is_equal_to_tensor">
<code class="descname">is_equal_to_tensor</code><span class="sig-paren">(</span><em>other</em>, <em>tol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.is_equal_to_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.is_equal_to_tensor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function takes in a another object and a tolerance value and     determines whether or not the input tensor is either elementwise equal to     or with a tolerance range of another tensor.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt>other - (unspecified)</dt>
<dd><p class="first last">object to compare the tensor with, may be any time, but will only         return true if the input is a Tensor instance</p>
</dd>
<dt>tol - (float)</dt>
<dd><p class="first last">the tolerance to declare whether or not a tensor is elementwise         close enough. uses the absolute value, b - tol &lt; a &lt; b + tol.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>(bool)</dt>
<dd><p class="first last">indicates whether or not the two tensors are equal.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>file_name</em>, <em>make_new=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.load" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function takes in a file name and loads in into the current tensor     instance, if the make_new flag is true it will return a new instance of a     tensor.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first last docutils">
<dt>file_name - (string)</dt>
<dd><p class="first last">The name of the file to load the tensor from.</p>
</dd>
<dt>make_new - (bool)</dt>
<dd><p class="first last">Optional bool which indicates whether or not to create a new instance of
a tensor, or just copy it into the current instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.norm" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function returns the norm (defined with the t product) of the     tensor called upon. Method is computed in a manner rebust to     over/underflow by scaling by the largest element of the tensor.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>norm - (float)</dt>
<dd><p class="first last">a float indicating the size of the tensor.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>shape</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.resize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.resize" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function takes in a 3 tuple and resizes the tensor according to     the dimension of the values passed into the tuple. The method will     default to row major order (C like) but may be done in col major order     (Fortran like).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first last docutils">
<dt>shape - (tuple or list of postive ints)</dt>
<dd><p class="first last">a tuple or list with at most length 3 which has the appropriate shapes.</p>
</dd>
<dt>order - (optional character)</dt>
<dd><p class="first last">a character indicating whether or not to use column or row major         formatting for the reshape.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>file_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.save" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function takes in a file name and uses the pickle module to save     the Tensor instance.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first last docutils">
<dt>file_name - (string)</dt>
<dd><p class="first last">The name of the file to save the tensor.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.scale_tensor">
<code class="descname">scale_tensor</code><span class="sig-paren">(</span><em>scalar</em>, <em>inPlace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.scale_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.scale_tensor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function takes in a scalar value and either returns a Tensor scaled     by a scalar in the field or scales the tensor in question in place and     returns nothing.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first last docutils">
<dt>scalar - (subclass of Number)</dt>
<dd><p class="first last">must be a scalar value of a field, will be applied to each of the         tensor slices.</p>
</dd>
<dt>inPlace - (optional bool)</dt>
<dd><p class="first last">a bool indicating whether or not the tensor this function is called         on should be scaled, or whether it should return a new tensor.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.set_frontal_slice">
<code class="descname">set_frontal_slice</code><span class="sig-paren">(</span><em>ts</em>, <em>frontal_slices</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.set_frontal_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.set_frontal_slice" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Replaces the t-th frontal slice. Paired with get_slice().</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first last docutils">
<dt>ts - (int or slice)</dt>
<dd><p class="first last">index or slice object of the slices to replace. t must be in range of         the number of frontal slices. Use a constructor to create larger         Tensors.</p>
</dd>
<dt>frontal_slice - (sparse scipy matrix)</dt>
<dd><p class="first last">the new t-th slice</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>TODO:</dt>
<dd>Update to match scipy.sparse and ndarray setting interface.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.set_scalar">
<code class="descname">set_scalar</code><span class="sig-paren">(</span><em>k</em>, <em>j</em>, <em>i</em>, <em>scalar</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.set_scalar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.set_scalar" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function sets i,j,k element of the tensor to be the value passed     as the scalar variable.Note that because COO matrices don’t support     assignment, the tensor must be converted. paired with the get_scalar     function.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first last docutils">
<dt>i - (integer)</dt>
<dd><p class="first last">The mode 1 index to insert the scalar</p>
</dd>
<dt>j - (integer)</dt>
<dd><p class="first last">The mode 2 index to insert the scalar</p>
</dd>
<dt>k - (integer)</dt>
<dd><p class="first last">The mode 3 index to insert the scalar</p>
</dd>
<dt>scalar - (scalar type)</dt>
<dd><p class="first last">The value to be inserted into the tensor, will be cast to the type         of whatever type of matrix the slices are comprised of.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>TODO:</dt>
<dd>-expand the tensor when the use passes an index out of range of the       current</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>X=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function takes in either an n x m matrix and will return a     (n x 1 x m) Tensor. This corresponds to thinking of the matrix as a     frontal slice, and having the function return it as a lateral slice.     Note that if no matrix is passed in, then this function will apply the     squeeze function to each one of the frontal slices of the current     instance of the tensor. Note that this function is paired with the     twist function as an inverse i.e.                         X = twist(squeeze(X))     It should be noted that X will be a dok sparse matrix after the     function calls.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first last docutils">
<dt>X - (optional n x m sparse matrix or ndarray)</dt>
<dd><p class="first last">A sparse matrix or ndarrayto be squeezed. Note if none is passed in,         then each frontal slice in self._slices will be squeezed and the         instance of the Tensor calling this function will be altered.     :Returns:</p>
</dd>
<dt>Z - (n x 1 x m Tensor)</dt>
<dd><p class="first last">A tensor corresponding to a single lateral slice. Doesn’t return         anything if no X is passed in.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.t_product">
<code class="descname">t_product</code><span class="sig-paren">(</span><em>B</em>, <em>transpose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.t_product"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.t_product" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function takes in another tensor instance and computes the     t-product of the two through the block circulant definition of the     operation.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt>B - (Tensor Instance)</dt>
<dd><p class="first last">the mode-2 and mode -3 dimensions of the current instance of a         tensor must equal the mode 1 and mode 3 dimensions of B.</p>
</dd>
<dt>transpose - (optional bool)</dt>
<dd><p class="first last">a boolean indicating whether or not to transpose the tensor being         called upon before applying the t-product.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(Tensor Instance)
Returns a new Tensor which represents the t-product of the current       Tensor and B.</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>TODO:</dt>
<dd>Can use a complex multiplication formula which may be a little less       numerically stable, but will improve complex matrix matrix       multiplication constants.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.todense">
<code class="descname">todense</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.todense"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.todense" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will convert the current tensor instance into a dense     tensor, or if make_new is true, will return a dense tensor instance.</p>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>inPlace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.transpose" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Creates a new instance a tensor class such that the frontal slices     are transposed, and the 2nd through nth slices are flipped. Has the     option of returning a new instance, or in place.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt>InPlace - (optional bool)</dt>
<dd><p class="first last">A boolean indicating whether or not to alter the current tensor,         or produce a new one.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Tensor Instance</dt>
<dd><p class="first last">if InPlace is false, then this function returns a new tensor         instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>TODO:</dt>
<dd>In the dense case, need to find out when np.reshape will create a       copy of the data under the hood.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.tubal_angle">
<code class="descname">tubal_angle</code><span class="sig-paren">(</span><em>B</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.tubal_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.tubal_angle" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function returns the tubal angle of the current instance of a     tensor with another tensor B passed in. This is defined using the inner     product defined by the t-product.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>cos_distance - (float)</dt>
<dd><p class="first last">the cosine distance between the current tensor and the tensor passed in.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.twist">
<code class="descname">twist</code><span class="sig-paren">(</span><em>X=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.twist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.twist" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function takes in an optional n x 1 x m tensor X and returns a     sparse n x m matrix corresponding to rotating the lateral slice to a     frontal slice. If no tensor is passed in, the algorithm is run on each     of frontal slices of the tensor this routine is being called on. Note     that this is the inverse function of the squeeze function, i.e.                         X = squeeze(twist(X))</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt>X - (optional n x 1 x m Tensor)</dt>
<dd><p class="first last">This is a lateral slice to be converted to a matrix. Note that         if no tensor is passed in, then the routine is run on each of         the frontal slices of the current instance of the Tensor the         function is called on.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Z - (sparse dok matrix or ndarray)</dt>
<dd><p class="first last">a matrix corresponding to the lateral slice. The type is determined          by whether the input tensor is dense or sparse.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.zero_out">
<code class="descname">zero_out</code><span class="sig-paren">(</span><em>threshold</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.zero_out"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.zero_out" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function iterates through the non-zeros of the tensor and zeros     them out if their absolute value is below the threshold given.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first last docutils">
<dt>threshold - (float)</dt>
<dd><p class="first last">the tolerance to delete and entry with.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Tensor.normalize">
<code class="descclassname">Tensor.</code><code class="descname">normalize</code><span class="sig-paren">(</span><em>X</em>, <em>return_sparse_a=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#normalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes in a lateral slice and returns a lateral slice a and   lateral slice V with frobenius norm 1 such that V t_prod a is the original   lateral slice passed in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt>X - (Tensor Instance)</dt>
<dd><p class="first last">the lateral slice passed in to be normalized.</p>
</dd>
<dt>return_sparse_a - (optional bool)</dt>
<dd><p class="first last">a boolean indicating whether or not the lateral slices should be returned       as sparse tensor or not.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>a - (Tensor Instance)</dt>
<dd><p class="first last">A lateral slice with the tubal scalars in each of the rows</p>
</dd>
<dt>V - (Tensor Instance)</dt>
<dd><p class="first last">the lateral slice with frobenius norm 1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Tensor.random">
<code class="descclassname">Tensor.</code><code class="descname">random</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#random"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.random" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function takes in a tuple indicating the size, and a dtype string   compatible with scipy’s data types and returns a Tensor instance   corresponding to shape passed of a given density, .</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt>shape - (list or tuple of ints)</dt>
<dd><p class="first last">a list or tuple with the dimensions of each of the 3 modes. must be of       length 3.</p>
</dd>
<dt>dtype - (dtype)</dt>
<dd><p class="first last">a datatype consistent with scipy sparse datatype standards</p>
</dd>
<dt>format - (string)</dt>
<dd><p class="first last">the format of the sparse matrices to produce, default is COO.</p>
</dd>
<dt>random_state - (int)</dt>
<dd><p class="first last">an integer which is passed in as a seed for each of the slices. Each       slice will increment the seed value by 1, so each slice will have a       unique seed.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>random_Tensor - (Tensor Instance)</dt>
<dd><p class="first last">an instance of a Tensor of the appropriate dimensions with all zeros.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Tensor.sparse_givens_rotation">
<code class="descclassname">Tensor.</code><code class="descname">sparse_givens_rotation</code><span class="sig-paren">(</span><em>A</em>, <em>i</em>, <em>j</em>, <em>i_swap</em>, <em>apply=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#sparse_givens_rotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.sparse_givens_rotation" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function takes in a Tensor instance and a row and column and either   returns a sparse tensor instance corresponding to the tubal givens   rotation corresponding to zeroing out the ith ,jth tubal scalar or it   will apply it to the tensor passed in.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt>A - (Tensor Instance)</dt>
<dd><p class="first last">the tensor to compute the givens rotation for.</p>
</dd>
<dt>i - (int)</dt>
<dd><p class="first last">the row of the tubal scalar to zero out.</p>
</dd>
<dt>j - (int)</dt>
<dd><p class="first last">the column of the tubal scalar to zero out.</p>
</dd>
<dt>i_swap - (int)</dt>
<dd><p class="first last">the second row of the tubal scalar to rotate with respect to.</p>
</dd>
<dt>apply - (optional boolean)</dt>
<dd><p class="first last">a bool which indicates whether or not to the apply the givens rotation to       the tensor rather than return a tensor instance corresponding to the       givens rotation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Q - (Tensor Instance)</dt>
<dd><p class="first last">if apply is False (default), then Q will be the tensor instance to       which the</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>TODO:</dt>
<dd>handle i_swap tests to ensure that i =/= i_swap</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="Tensor.zeros">
<code class="descclassname">Tensor.</code><code class="descname">zeros</code><span class="sig-paren">(</span><em>shape</em>, <em>dtype=None</em>, <em>format='coo'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#zeros"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.zeros" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function takes in a tuple indicating the size, and a dtype string   compatible with scipy’s data types and returns a Tensor instance corresponding   to shape passed in filled with all zeros.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt>shape - (list or tuple of ints)</dt>
<dd><p class="first last">a list or tuple with the dimensions of each of the 3 modes. must be of       length 3.</p>
</dd>
<dt>format - (string)</dt>
<dd><p class="first last">the format of the sparse matrices to produce, default is COO.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Zero_Tensor - (Tensor Instance)</dt>
<dd><p class="first last">an instance of a Tensor of the appropriate dimensions with all zeros.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to T_Tensor’s documentation!</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Charles Colley.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>