
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Welcome to T_Tensor’s documentation! &#8212; T_Tensor 1.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="welcome-to-t-tensor-s-documentation">
<h1>Welcome to T_Tensor’s documentation!<a class="headerlink" href="#welcome-to-t-tensor-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<span class="target" id="module-Tensor"></span><dl class="class">
<dt id="Tensor.Tensor">
<em class="property">class </em><code class="descclassname">Tensor.</code><code class="descname">Tensor</code><span class="sig-paren">(</span><em>slices=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>This is a class of 3rd order sparse tensors which is designed to support
the t-product.</p>
<dl class="docutils">
<dt>Tensor Class</dt>
<dd><dl class="first last docutils">
<dt>Private:</dt>
<dd><dl class="first last docutils">
<dt>_slices - (list of sparse matrices or 3rd order ndarray)</dt>
<dd>a list of sparse scipy matrices which represents the frontal slices of
the tensor, i.e. the t-th element of the list will be the matrix
A[:,:,t]. All slices will be the same type of sparse matrix. If
slices is passed in as an ndarray, then it must only have 3
dimensions.</dd>
<dt>_slice_format - (string)</dt>
<dd>a string indicating the sparse matrix format of each of the frontal
slices in the tensor. If _slices is an ndarray it will be set to
‘dense’</dd>
<dt>shape - (tuple of ints)</dt>
<dd>a tuple with the shape of the tensor. The ith element of shape
corresponds to the dimension of the ith mode.</dd>
</dl>
</dd>
<dt>Public Methods:</dt>
<dd>save
load
convert_slices
set_frontal_slice
get_front_slice
set_scalar
get_scalar
resize                SPARSE UNFINISHED
transpose              DENSE UNTESTED
squeeze
twist
t-product                    WRITE DENSE CASE
scale_tensor
find_max
is_equal_to_tensor
frobenius_norm               UNTESTED
norm                         UNTESTED
cos_distance m
to_dense</dd>
<dt>Overloaded Methods:</dt>
<dd>__add__
__sub__
__mul__                      UNTESTED
__neg__
__eq__                       UNTESTED
__ne
__getitem__                  DENSE UNTESTED
__setitem__                  UNWRITTEN</dd>
</dl>
</dd>
<dt>Class utilization</dt>
<dd>zeros
normalize</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>TODO: -write a reshape function</dt>
<dd>-update the convert slices to convert to dense or to sparse
-write random Tensor
-write print overloading
-add in non-zero count private element?</dd>
</dl>
<dl class="method">
<dt id="Tensor.Tensor.convert_slices">
<code class="descname">convert_slices</code><span class="sig-paren">(</span><em>format</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.convert_slices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.convert_slices" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function will convert all of the slices to a desired sparse matrix
format, this derives its functionality from the scipy.sparse._.asformat
function. To convert to a dense tensor, use todense().</div></blockquote>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>format- (string)</dt>
<dd>string that specifies the possible formats, valid formats are the
supported formats of scipy sparse matrices. see scipy reference for
most up to date supported formats</dd>
</dl>
</dd>
<dt>References:</dt>
<dd><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/sparse.html">https://docs.scipy.org/doc/scipy/reference/sparse.html</a></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.find_max">
<code class="descname">find_max</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.find_max"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.find_max" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function returns the largest element of the tensor.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.frobenius_norm">
<code class="descname">frobenius_norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.frobenius_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.frobenius_norm" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><blockquote>
<div>Returns the Frobenius norm of the tensor. Computed using scipy’s norm</div></blockquote>
<p>function for numerical stability.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.get_frontal_slice">
<code class="descname">get_frontal_slice</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.get_frontal_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.get_frontal_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the t-th frontal slice. Paired with set_slice().
Input:</p>
<blockquote>
<div><dl class="docutils">
<dt>t - (int)</dt>
<dd>index of the slice to return</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>slice - (sparse scipy matrix or ndarray)</dt>
<dd>the t-th slice</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.get_scalar">
<code class="descname">get_scalar</code><span class="sig-paren">(</span><em>k</em>, <em>j</em>, <em>i</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.get_scalar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.get_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the i,j,k element of the tensor. paired with the
set_scalar function.</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>i - (integer)</dt>
<dd>The mode 1 index to insert the scalar</dd>
<dt>j - (integer)</dt>
<dd>The mode 2 index to insert the scalar</dd>
<dt>k - (integer)</dt>
<dd>The mode 3 index to insert the scalar</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>A[i,j,k] - (scalar number)</dt>
<dd>returns the value at the i,j element of the kth frontal slice.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.is_equal_to_tensor">
<code class="descname">is_equal_to_tensor</code><span class="sig-paren">(</span><em>other</em>, <em>tol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.is_equal_to_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.is_equal_to_tensor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This function takes in a another object and a tolerance value and
determines whether or not the input tensor is either elementwise equal to
or with a tolerance range of another tensor.</div></blockquote>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>other - (unspecified)</dt>
<dd>object to compare the tensor with, may be any time, but will only
return true if the input is a Tensor instance</dd>
<dt>tol - (float)</dt>
<dd>the tolerance to declare whether or not a tensor is elementwise
close enough. uses the absolute value, b - tol &lt; a &lt; b + tol.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>(bool)</dt>
<dd>indicates whether or not the two tensors are equal.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>file_name</em>, <em>make_new=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.load" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes in a file name and loads in into the current tensor
instance, if the make_new flag is true it will return a new instance of a
tensor.
Input:</p>
<blockquote>
<div><dl class="docutils">
<dt>file_name - (string)</dt>
<dd>The name of the file to load the tensor from.</dd>
<dt>make_new - (bool)</dt>
<dd>Optional bool which indicates whether or not to create a new instance of
a tensor, or just copy it into the current instance.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the norm (defined with the t product) of the
tensor called upon. Method is computed in a manner rebust to
over/underflow by scaling by the largest element of the tensor.
Returns:</p>
<blockquote>
<div><dl class="docutils">
<dt>norm - (float)</dt>
<dd>a float indicating the size of the tensor.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>shape</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.resize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes in a 3 tuple and resizes the tensor according to
the dimension of the values passed into the tuple. The method will
default to row major order (C like) but may be done in col major order
(Fortran like).</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>shape - (tuple or list of postive ints)</dt>
<dd>a tuple or list with at most length 3 which has the appropriate shapes.</dd>
<dt>order - (optional character)</dt>
<dd>a character indicating whether or not to use column or row major
formatting for the reshape.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>file_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.save" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes in a file name and uses the pickle module to save
the Tensor instance.
Input:</p>
<blockquote>
<div><dl class="docutils">
<dt>file_name - (string)</dt>
<dd>The name of the file to save the tensor.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.scale_tensor">
<code class="descname">scale_tensor</code><span class="sig-paren">(</span><em>scalar</em>, <em>inPlace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.scale_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.scale_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes in a scalar value and either returns a Tensor
scaled by a scalar in the field or scales the tensor in question in
place and returns nothing.</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>scalar - (subclass of Number)</dt>
<dd>must be a scalar value of a field, will be applied to each of the
tensor slices.</dd>
<dt>inPlace - (optional bool)</dt>
<dd>a bool indicating whether or not the tensor this function is called
on should be scaled, or whether it should return a new tensor.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.set_frontal_slice">
<code class="descname">set_frontal_slice</code><span class="sig-paren">(</span><em>ts</em>, <em>frontal_slices</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.set_frontal_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.set_frontal_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>replaces the t-th frontal slice. Paired with get_slice().</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>ts - (int or slice)</dt>
<dd>index or slice object of the slices to replace. t must be in
range of the number of frontal slices. Use a constructor to
create larger Tensors.</dd>
<dt>frontal_slice - (sparse scipy matrix)</dt>
<dd>the new t-th slice</dd>
</dl>
</dd>
<dt>TODO:</dt>
<dd>Update to match scipy.sparse and ndarray setting interface.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.set_scalar">
<code class="descname">set_scalar</code><span class="sig-paren">(</span><em>k</em>, <em>j</em>, <em>i</em>, <em>scalar</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.set_scalar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.set_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>This function sets i,j,k element of the tensor to be the value
passed as the scalar variable.Note that because COO matrices don’t
support assignment, the tensor must be converted. paired with the
get_scalar function.</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>i - (integer)</dt>
<dd>The mode 1 index to insert the scalar</dd>
<dt>j - (integer)</dt>
<dd>The mode 2 index to insert the scalar</dd>
<dt>k - (integer)</dt>
<dd>The mode 3 index to insert the scalar</dd>
<dt>scalar - (scalar type)</dt>
<dd>The value to be inserted into the tensor, will be cast to the type
of whatever type of matrix the slices are comprised of.</dd>
</dl>
</dd>
<dt>TODO:</dt>
<dd><dl class="first last docutils">
<dt>-expand the tensor when the use passes an index out of range of the</dt>
<dd>current</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>X=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes in either an n x m matrix and will return a
(n x 1 x m) Tensor. This corresponds to thinking of the matrix as a
frontal slice, and having the function return it as a lateral slice.
Note that if no matrix is passed in, then this function will apply the
squeeze function to each one of the frontal slices of the current
instance of the tensor. Note that this function is paired with the
twist function as an inverse i.e.</p>
<blockquote>
<div>X = twist(squeeze(X))</div></blockquote>
<p>It should be noted that X will be a dok sparse matrix after the
function calls.
Input:</p>
<blockquote>
<div><dl class="docutils">
<dt>X - (optional n x m sparse matrix or ndarray)</dt>
<dd><dl class="first last docutils">
<dt>A sparse matrix or ndarrayto be squeezed. Note if none is passed in,</dt>
<dd>then each frontal slice in self._slices will be squeezed and the
instance of the Tensor calling this function will be altered.</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Z - (n x 1 x m Tensor)</dt>
<dd>A tensor corresponding to a single lateral slice. Doesn’t return
anything if no X is passed in.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.t_product">
<code class="descname">t_product</code><span class="sig-paren">(</span><em>B</em>, <em>transpose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.t_product"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.t_product" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes in another tensor instance and computes the
t-product of the two through the block circulant definition of the
operation.</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>B - (Tensor Instance)</dt>
<dd>the mode-2 and mode -3 dimensions of the current instance of a
tensor must equal the mode 1 and mode 3 dimensions of B.</dd>
<dt>transpose - (optional bool)</dt>
<dd>a boolean indicating whether or not to transpose the tensor being
called upon before applying the t-product.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Tensor Instance
Returns a new Tensor which represents the t-product of the current
Tensor and B.</dd>
<dt>Notes:</dt>
<dd>Develop future support for dense case</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.todense">
<code class="descname">todense</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.todense"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.todense" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>this function will convert the current tensor instance into a dense</div></blockquote>
<p>tensor, or if make_new is true, will return a dense tensor instance.</p>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>inPlace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new instance a tensor class such that the frontal slices
are transposed, and the 2nd through nth slices are flipped. Has the
option of returning a new instance, or in place.</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>InPlace - (optional bool)</dt>
<dd>A boolean indicating whether or not to alter the current tensor,
or produce a new one.</dd>
</dl>
</dd>
<dt>Return:</dt>
<dd><dl class="first last docutils">
<dt>Tensor Instance</dt>
<dd>if InPlace is false, then this function returns a new tensor
instance.</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>In the dense case, need to find out when np.reshape will create a
copy of the data under the hood.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.tubal_angle">
<code class="descname">tubal_angle</code><span class="sig-paren">(</span><em>B</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.tubal_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.tubal_angle" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><blockquote>
<div>This function returns the tubal angle of the current instance of a</div></blockquote>
<p>tensor with another tensor B passed in. This is defined using the inner
product defined by the t-product.</p>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>cos_distance - (float)</dt>
<dd>the cosine distance between the current tensor and the tensor passed in.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Tensor.Tensor.twist">
<code class="descname">twist</code><span class="sig-paren">(</span><em>X=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#Tensor.twist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.Tensor.twist" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes in an optional n x 1 x m tensor X and returns a
sparse n x m matrix corresponding to rotating the lateral slice to a
frontal slice. If no tensor is passed in, the algorithm is run on each
of frontal slices of the tensor this routine is being called on. Note
that this is the inverse function of the squeeze function, i.e.</p>
<blockquote>
<div>X = squeeze(twist(X))</div></blockquote>
<dl class="docutils">
<dt>Input:</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>X - (optional n x 1 x m Tensor)</dt>
<dd>This is a lateral slice to be converted to a matrix. Note that
if no tensor is passed in, then the routine is run on each of
the frontal slices of the current instance of the Tensor the
function is called on.</dd>
</dl>
</div></blockquote>
<dl class="last docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Z - (sparse dok matrix or ndarray)</dt>
<dd>a matrix corresponding to the lateral slice. The type is determined
by whether the input tensor is dense or sparse.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Tensor.normalize">
<code class="descclassname">Tensor.</code><code class="descname">normalize</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#normalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.normalize" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><blockquote>
<div><blockquote>
<div>This function takes in a lateral slice and returns a tubal scalar a and</div></blockquote>
<p>lateral slice V with frobenius norm 1 such that V t_prod a is the
original lateral slice passed in.</p>
</div></blockquote>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>X - (Tensor Instance)</dt>
<dd>the lateral slice passed in to be normalized.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>a - (Tensor Instance)</dt>
<dd>the tubal scale.</dd>
<dt>V - (Tensor Instance)</dt>
<dd>the lateral slice with frobenius norm 1</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>This function should be expanded to take in a full tensor and apply it
to each slice.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="Tensor.random">
<code class="descclassname">Tensor.</code><code class="descname">random</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#random"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.random" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><blockquote>
<div><blockquote>
<div>This function takes in a tuple indicating the size, and a dtype</div></blockquote>
<p>string compatible with scipy’s data types and returns a Tensor instance
corresponding to shape passed of a given density, .</p>
</div></blockquote>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>shape - (list or tuple of ints)</dt>
<dd>a list or tuple with the dimensions of each of the 3 modes. must be of
length 3.</dd>
<dt>dtype - (dtype)</dt>
<dd>a datatype consistent with scipy sparse datatype standards</dd>
<dt>format - (string)</dt>
<dd>the format of the sparse matrices to produce, default is COO.</dd>
<dt>random_state - (int)</dt>
<dd>an integer which is passed in as a seed for each of the slices. Each
slice will increment the seed value by 1, so each slice will have a
unique seed.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>random_Tensor - (Tensor Instance)</dt>
<dd>an instance of a Tensor of the appropriate dimensions with all zeros.</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="Tensor.sparse_givens_rotation">
<code class="descclassname">Tensor.</code><code class="descname">sparse_givens_rotation</code><span class="sig-paren">(</span><em>A</em>, <em>i</em>, <em>j</em>, <em>i_swap</em>, <em>apply=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#sparse_givens_rotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.sparse_givens_rotation" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><blockquote>
<div>This function takes in a Tensor instance and a row and column and either
returns a sparse tensor instance corresponding to the tubal givens
rotation corresponding to zeroing out the ith ,jth tubal scalar or it
will apply it to the tensor passed in.</div></blockquote>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>A - (Tensor Instance)</dt>
<dd>the tensor to compute the givens rotation for.</dd>
<dt>i - (int)</dt>
<dd>the row of the tubal scalar to zero out.</dd>
<dt>j - (int)</dt>
<dd>the column of the tubal scalar to zero out.</dd>
<dt>i_swap - (int)</dt>
<dd>the second row of the tubal scalar to rotate with respect to.</dd>
<dt>apply - (optional boolean)</dt>
<dd><blockquote class="first">
<div>a bool which indicates whether or not to the apply the givens</div></blockquote>
<p class="last">rotation to the tensor rather than return a tensor instance
corresponding to the givens rotation.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>Q - (Tensor Instance)</dt>
<dd>if apply is False (default), then Q will be the tensor instance to
which the</dd>
</dl>
</div></blockquote>
<dl class="last docutils">
<dt>Note:</dt>
<dd>handle i_swap tests to ensure that i =/= i_swap</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="Tensor.zeros">
<code class="descclassname">Tensor.</code><code class="descname">zeros</code><span class="sig-paren">(</span><em>shape</em>, <em>dtype=None</em>, <em>format='coo'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Tensor.html#zeros"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Tensor.zeros" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><blockquote>
<div>This function takes in a tuple indicating the size, and a dtype
string compatible with scipy’s data types and returns a Tensor instance
corresponding to shape passed in filled with all zeros.</div></blockquote>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>shape - (list or tuple of ints)</dt>
<dd>a list or tuple with the dimensions of each of the 3 modes. must be of
length 3.</dd>
<dt>format - (string)</dt>
<dd>the format of the sparse matrices to produce, default is COO.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Zero_Tensor - (Tensor Instance)</dt>
<dd>an instance of a Tensor of the appropriate dimensions with all zeros.</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to T_Tensor’s documentation!</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Charles Colley.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>